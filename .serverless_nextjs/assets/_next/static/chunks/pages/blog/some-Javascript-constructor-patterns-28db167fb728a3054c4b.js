_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[38],{ePmY:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/some-Javascript-constructor-patterns",function(){return n("jM3x")}])},jM3x:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n("rePB"),o=n("Ff2n"),r=(n("q1tI"),n("7ljp")),i=n("ZDfL");function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){Object(a.a)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var c={title:"Some Javascript constructor patterns, and when to use them",date:"2013-11-14",__resourcePath:"blog/some-Javascript-constructor-patterns/index.md",__scans:{},layout:"index"},b={frontMatter:c},h=i.a;function p(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)(h,l(l(l({},b),n),{},{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"As I've been writing more and more JavaScript, I've learned something about the community: Javascripters like to do things differently. Ask two developers, or look at two different popular open-source projects, and you'll probably come across two different solutions for doing the same thing, whether it's as trivial as writing getter/setter methods or as complicated as loading modules. Sometimes I'm able to find a consensus around these solutions, but often I get lost among the alternatives, and find it difficult to determine which is most appropriate for my specific use case."),Object(r.b)("p",null,"One example is writing constructors. I've come across several ways to do it - but which way is right? Why do some libraries choose one method, and some another? In this post, I'd like to explore some of the techniques I've encountered for writing constructor functions, their pros and cons, and when to use them."),Object(r.b)("h2",null,"Generic advice - using the new keyword (Mozilla)"),Object(r.b)("p",null,"If I had to describe the 'standard' constructor pattern I've seen, it's probably this:"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-js"}),'// The constructor - like a class, but actually, not really\nfunction Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n\n  this.fullName = function () {\n    return this.firstName + " " + this.lastName;\n  };\n}\n\n// Use it like this:\nvar sam = new Person("Sam", "Selikoff");\nsam.firstName; // "Sam"\nsam.fullName(); // "Sam Selikoff"\n\nsam.firstName = "Samuel";\nsam.fullName(); // Samuel Selikoff\n')),Object(r.b)("p",null,"This looks a lot like something you'd see in other languages - but don't get too comfortable. If you instantiate two objects this way, they won't necessarily always have the same properties and methods. This is because Javascript lets you mutate objects at run-time:"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-js"}),'// Add a gender property to this instance only\nsam.gender = "male";\n')),Object(r.b)("p",null,"You are also able to change existing methods and properties on your objects, and this may lead to behavior you don't expect. For example, if you changed the ",Object(r.b)("inlineCode",{parentName:"p"},"fullName")," method on a single object, those changes wouldn't be shared across other objects. This is because the ",Object(r.b)("inlineCode",{parentName:"p"},"fullName")," method is an anonymous function that's attached directly to an instance variable. Each object will get its own copy of the function."),Object(r.b)("p",null,"If you wanted the function to be shared across all ",Object(r.b)("inlineCode",{parentName:"p"},"Person")," objects, you could do it like this:"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-js"}),'function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nPerson.prototype.fullName = function () {\n  return this.firstName + " " + this.lastName;\n};\n')),Object(r.b)("p",null,"This constructor shares the ",Object(r.b)("inlineCode",{parentName:"p"},"fullName")," method across all instances. But how does it work?"),Object(r.b)("h2",null,"Some Javascript eccentricities"),Object(r.b)("p",null,"Whenever we create objects using the ",Object(r.b)("inlineCode",{parentName:"p"},"new")," keyword (as we've been doing), those objects get a special reference to the ",Object(r.b)("inlineCode",{parentName:"p"},"Person.prototype")," dictionary. (In Javascript, dictionaries are synonymous with objects, but I'm using the term here to describe objects that are used mainly as key-value references). Prototypes in Javascript give objects a chain of dictionaries used to look up methods. This means that if we call a method on an object, but that method isn't defined directly on the object, Javscript will look for the method in the next level of the object's ",Object(r.b)("em",{parentName:"p"},"prototype chain"),". If it finds it, it will invoke the method; if not, it will keep looking up the chain."),Object(r.b)("p",null,"In our first example, we didn't define a prototype on the ",Object(r.b)("inlineCode",{parentName:"p"},"Person")," constructor, so all instances of ",Object(r.b)("inlineCode",{parentName:"p"},"Person")," had prototype chains that were only one level deep, so to speak; that is, they only contained the default ",Object(r.b)("inlineCode",{parentName:"p"},"Object.prototype")," dictionary. This dictionary contains methods that all objects tend to have in other languages - ",Object(r.b)("inlineCode",{parentName:"p"},"toString"),", for instance."),Object(r.b)("p",null,"In our second example, we explicitly created a dictionary on the ",Object(r.b)("inlineCode",{parentName:"p"},"prototype")," property of the constructor. The ",Object(r.b)("inlineCode",{parentName:"p"},"new")," keyword is aware of this property: it is designed to check if there's a dictionary at ",Object(r.b)("inlineCode",{parentName:"p"},".prototype"),", and if there is, it adds it to the prototype chain of the object it's currently instantiating. This means that when we call ",Object(r.b)("inlineCode",{parentName:"p"},"sam.fullName()"),", Javascript first looks (unsuccessfully) for the method directly on the ",Object(r.b)("inlineCode",{parentName:"p"},"sam")," instance, and then moves on to the next level of ",Object(r.b)("inlineCode",{parentName:"p"},"sam"),"'s prototype chain, which is the dictionary we created. Because that dictionary ",Object(r.b)("em",{parentName:"p"},"does")," have the ",Object(r.b)("inlineCode",{parentName:"p"},"fullName")," method, that method gets invoked. And because all objects that get instantiated from the ",Object(r.b)("inlineCode",{parentName:"p"},"Person")," constructor have a reference to the same prototype dictionary, they all refer to the same method. So this is how we can share methods across objects."),Object(r.b)("p",null,"Before moving on to the next pattern, we should cover our use of the ",Object(r.b)("inlineCode",{parentName:"p"},"this")," keyword. I'm sure you've come across many JavaScript posts outlining the dangers of being ignorant of ",Object(r.b)("inlineCode",{parentName:"p"},"this"),". We use it in the above construct - so what do we need to be careful of?"),Object(r.b)("p",null,"First, a brief overview. ",Object(r.b)("inlineCode",{parentName:"p"},"this")," is a keyword that's available in every Javascript function. It's really just a pointer. But what does it point to? ",Object(r.b)("strong",{parentName:"p"},"The ",Object(r.b)("inlineCode",{parentName:"strong"},"this")," keyword points to the object that's invoking the current function.")),Object(r.b)("p",null,"So, the ",Object(r.b)("inlineCode",{parentName:"p"},"this")," keyword is really just a pointer to an object. But the ",Object(r.b)("inlineCode",{parentName:"p"},"new")," keyword does something nice for us: it tells ",Object(r.b)("inlineCode",{parentName:"p"},"this")," to point to the object that's being instantiated. In this example from above,"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-js"}),'var sam = new Person("Sam", "Selikoff");\n')),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"this")," pointed to ",Object(r.b)("inlineCode",{parentName:"p"},"sam")," whenever it was used inside the ",Object(r.b)("inlineCode",{parentName:"p"},"Person")," constructor function. If we hadn't used ",Object(r.b)("inlineCode",{parentName:"p"},"new"),", though, ",Object(r.b)("inlineCode",{parentName:"p"},"this")," would have referred to the global object, since that was the object executing the constructor function. For example:"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-js"}),'var george = Person("George", "Foreman"); // forgot \'new\'\ngeorge; // undefined\n')),Object(r.b)("p",null,"Poor ",Object(r.b)("inlineCode",{parentName:"p"},"george")," is undefined! This is because when ",Object(r.b)("inlineCode",{parentName:"p"},"Person")," was invoked, ",Object(r.b)("inlineCode",{parentName:"p"},"this")," referred to the global object. That means these two lines within our constructor function"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-js"}),"this.firstName = firstName;\nthis.lastName = lastName;\n")),Object(r.b)("p",null,"really just created two new global variables, ",Object(r.b)("inlineCode",{parentName:"p"},"firstName")," and ",Object(r.b)("inlineCode",{parentName:"p"},"lastName"),". When ",Object(r.b)("inlineCode",{parentName:"p"},"Person")," finished executing, it returned ",Object(r.b)("inlineCode",{parentName:"p"},"undefined")," (which happened by default, since it didn't return anything). So ",Object(r.b)("inlineCode",{parentName:"p"},"george")," is undefined, and you've got two new globals - most certainly not what you intended!"),Object(r.b)("p",null,"Therefore, it's important to remember to use the ",Object(r.b)("inlineCode",{parentName:"p"},"new")," keyword when using this pattern. Typically, constructors are capitalized (and instances lower-cased) to remind developers of this rule."),Object(r.b)("h2",null,"Closures with getter-setters (D3.js, jQuery)"),Object(r.b)("p",null,"We just saw that when using the above pattern, you need to manage the context of ",Object(r.b)("inlineCode",{parentName:"p"},"this")," by using the ",Object(r.b)("inlineCode",{parentName:"p"},"new")," keyword. If this troubles you, there is another technique which avoids ",Object(r.b)("inlineCode",{parentName:"p"},"this")," altogether."),Object(r.b)("p",null,"Here's an example of how it's used:"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-js"}),'function Person(firstName, lastName) {\n  var _firstName = firstName,\n    _lastName = lastName;\n\n  var my = {};\n\n  my.fullName = function () {\n    return _firstName + " " + _lastName;\n  };\n\n  // Getter/setters\n  my.firstName = function (value) {\n    if (!arguments.length) return _firstName;\n    _firstName = value;\n\n    return my;\n  };\n\n  my.lastName = function (value) {\n    if (!arguments.length) return _lastName;\n    _lastName = value;\n\n    return my;\n  };\n\n  return my;\n}\n\n// Use it like this:\nvar mark = Person("Mark", "Twain"); // note: no `new` keyword!\n\nmark.firstName("Samuel");\nmark.lastName("Clemens");\n\nmark.fullName(); // Samuel Clemens\n')),Object(r.b)("p",null,"I was confused about this pattern when I first encountered it; the first pattern seems much more intuitive and familiar. But notice that since we never use ",Object(r.b)("inlineCode",{parentName:"p"},"this"),", we simply don't have to worry about managing its context. No matter where we call ",Object(r.b)("inlineCode",{parentName:"p"},"mark.fullName()"),", or ",Object(r.b)("inlineCode",{parentName:"p"},"mark.firstName('Mark')"),", the instance variables we're manipulating (",Object(r.b)("inlineCode",{parentName:"p"},"_firstName")," and ",Object(r.b)("inlineCode",{parentName:"p"},"_lastName"),") will be the correct ones."),Object(r.b)("p",null,"It turns out that the biggest benefit of this technique has nothing to do with ",Object(r.b)("inlineCode",{parentName:"p"},"this"),", though. Rather, it's the ability to give your objects private properties and methods. In the example above, as you may have guessed, ",Object(r.b)("inlineCode",{parentName:"p"},"_firstName")," and ",Object(r.b)("inlineCode",{parentName:"p"},"_lastName")," are not publically accessible:"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-js"}),"mark._firstName;\n// undefined\n")),Object(r.b)("p",null,"How does this work?"),Object(r.b)("p",null,"Typically, when a function finishes executing, the variables declared within that function fall out of scope and get destroyed. But there's an exception: if any code outside the function holds a reference to these variables after the function finishes executing, they won't be cleaned up. Instead, a closure will be formed, and those variables will remain in memory."),Object(r.b)("p",null,"In the example above, since the ",Object(r.b)("inlineCode",{parentName:"p"},"Person")," constructor function returns the inner object ",Object(r.b)("inlineCode",{parentName:"p"},"my"),", and since ",Object(r.b)("inlineCode",{parentName:"p"},"my")," refers to the local variables ",Object(r.b)("inlineCode",{parentName:"p"},"_firstName")," and ",Object(r.b)("inlineCode",{parentName:"p"},"_lastName")," (both in the getter/setters and in the ",Object(r.b)("inlineCode",{parentName:"p"},"fullName")," method), the variables are not destroyed. When the getter/setters are invoked, they are operating on those same local variables."),Object(r.b)("p",null,"But why do this? Why go through this bizarre set of steps just to create what are essentially instance variables on an object - something we already know how to do? The difference between the local variables that the closure has access to and the instance variables on the objects we made earlier is that ",Object(r.b)("em",{parentName:"p"},"the outside world does not have direct access to the local variables"),"."),Object(r.b)("p",null,"In the objects from our first pattern, anybody with a reference to the ",Object(r.b)("inlineCode",{parentName:"p"},"sam")," object could change the ",Object(r.b)("inlineCode",{parentName:"p"},"firstName")," property to anything he pleases:"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-js"}),'sam.firstName = "Peter";\n')),Object(r.b)("p",null,"But the only way to access the variables using the current technique are through the getter/setter methods that we attached to ",Object(r.b)("inlineCode",{parentName:"p"},"my"),". By attaching those methods to ",Object(r.b)("inlineCode",{parentName:"p"},"my"),", we made them public; but the local variables themselves remain private. We can now add validation and other logic to our getter/setters, giving us more control over our object's interfaces."),Object(r.b)("p",null,"So we see that closures with getter/setters give us the ability to have private properties and methods, a feature of OOP we've come to expect from other languages."),Object(r.b)("h2",null,"The best of both worlds?"),Object(r.b)("p",null,"As we've seen, prototypes (from the first pattern) give us method sharing, and closures (from the second pattern) give us private properties. A natural follow-up question is: can we have both?"),Object(r.b)("p",null,"It turns out the that there's no way for shared methods that live on the constructor's prototype to access the object's hidden, private properties. This means that you effectively have to choose one or the other. But which one should you choose, and why?"),Object(r.b)("p",null,"If performance is crucial - for example, if you plan on making thousands of objects - you'll want to go with prototypes and shared methods. Removing redundant copies of methods is going to be a suggestion that any consultant or book on performance will make."),Object(r.b)("p",null,"On the other hand, if the object you're making is large and complex, and is designed mainly for public consumption, the flexibility that comes with having private properties and methods will probably win out, and you'll want to take advantage of closures. This is why libraries like jQuery and D3 tend to use closures: users will almost certainly only be using one instance of the library, which means that method sharing becomes less of an issue."),Object(r.b)("p",null,"As a clarifying note, you can certainly use prototypes and closures on the same object. But only the closures - which are ",Object(r.b)("em",{parentName:"p"},"not")," shared across instances - will have access to your object's private variables. The shared methods on the object's prototype will not."),Object(r.b)("h2",null,"Custom constructors (Ember.js, Backbone.js, etc.)"),Object(r.b)("p",null,"Sometimes when making objects within a framework or library, you'll avoid native Javascript constructors altogether. This allows the library to have more control over the objects in your application."),Object(r.b)("p",null,"In Ember, for example, you define objects by extending the base ",Object(r.b)("inlineCode",{parentName:"p"},"Ember.Object")," object, and then calling the ",Object(r.b)("inlineCode",{parentName:"p"},"create")," method on that object. You set properties by passing them into the constructor."),Object(r.b)("p",null,"Here's how it works:"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-js"}),'Person = Ember.Object.extend({\n  fullName: function () {\n    return this.get("firstName") + " " + this.get("lastName");\n  },\n});\n\nvar tim = Person.create({\n  firstName: "Tim",\n  lastName: "Tebow",\n});\n\ntim.fullName();\n// Tim Tebow\n')),Object(r.b)("p",null,"Custom methods like this may feel unnecessary or cumbersome, but they give a lot of power to library authors."),Object(r.b)("p",null,"For example, one of Ember's core features is its data bindings system, which requires that each object in an application have the ability to observe the properties of other objects. By giving developers a custom constructor function, Ember can implement this functionality in a consistent and controlled way, without requiring developers to write additional code just to mix in the behavior. So in this case, the custom constructor simplifies use of the framework for Ember developers. Underneath the hood, these custom constructors are simply wrappers around one of the two methods we covered."),Object(r.b)("p",null,"So depending on what you're designing and who you're designing it for, a custom constructor function may be the way to go."),Object(r.b)("h2",null,"No constructor, a.k.a. the object literal"),Object(r.b)("p",null,"Of course, you can always create an object using no constructor at all:"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-js"}),'var sam = {\n  firstName: "Sam",\n  lastName: "Selikoff",\n  fullName: function () {\n    return this.firstName + " " + this.lastName;\n  },\n};\n')),Object(r.b)("p",null,"This is known as an object literal. But you probably are interested in writing constructors because you plan on making many objects. Object literals won't help you there - but they do have plenty of uses, including storing configuration settings or raw data, or reducing the number of globals in your library."),Object(r.b)("h2",null,"Summary"),Object(r.b)("p",null,"The takeaway is that there are many ways to create objects in Javascript, each with its own costs and benefits. It's good to know the kinds of things these patterns let you accomplish, and how other developers have used them, so you can decide for yourself when a technique is appropriate in your own work."),Object(r.b)("p",null,"Here's a recap of what we discussed. Hopefully the next time you need to make some objects, you'll be better equipped to choose the appropriate method:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Prototypes")," let you share public methods across objects. (They also let you use inheritance).")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Closures")," let you have private properties and methods. They are often used in libraries. (Closures are part of a larger pattern called the Module pattern).")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Custom constructors")," can be useful when building specialized APIs.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Object literals")," are often used to store and pass around isolated chunks of data, like configuration settings or the parameters to an AJAX request. They can also help reduce the number of globals in your code."))),Object(r.b)("h2",null,"Learn more"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",l({parentName:"li"},{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects"}),"Mozilla: Working with Objects")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",l({parentName:"li"},{href:"http://stackoverflow.com/a/3658673/1406664"}),"A great SO answer on the ",Object(r.b)("inlineCode",{parentName:"a"},"new")," keyword")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",l({parentName:"li"},{href:"http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/"}),"Yehuda Katz: Understanding prototypes in Javascript")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",l({parentName:"li"},{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures"}),"Mozilla: Closures")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",l({parentName:"li"},{href:"http://yuiblog.com/blog/2007/06/12/module-pattern/"}),"Eric Miraglia, a Yahoo engineer, describes the Module pattern")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",l({parentName:"li"},{href:"http://bost.ocks.org/mike/chart/"}),"Mike Bostock, the author of D3, suggests using closures to build reusable charts")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",l({parentName:"li"},{href:"http://www.crockford.com/javascript/private.html"}),"Douglas Crockford: Private Members in Javascript"))))}p.isMDXComponent=!0}},[["ePmY",0,2,1,3,4,5,6]]]);