_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[28],{Kpt1:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"default",(function(){return u}));var o=n("rePB"),r=n("Ff2n"),a=(n("q1tI"),n("7ljp")),i=n("ZDfL");function p(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?p(Object(n),!0).forEach((function(t){Object(o.a)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):p(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var l={title:"Getting Ember components to respond to actions",date:"2014-05-16",__resourcePath:"blog/getting-ember-components-to-respond-to-actions/index.mdx",__scans:{},layout:"index"},s={frontMatter:l},b=i.a;function u(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(a.b)(b,c(c(c({},s),n),{},{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"I'm building a map application in Ember, and I need one of my components to invoke a method in another component. The UI is similar to Google Maps, with an overlay panel showing details about the selected pin:"),Object(a.b)("img",{src:"/_next/static/media/map.e60a5bf78b4ba6c0041ee4462888741c.png"}),Object(a.b)("p",null,"The router looks something like this:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),'App.Router.map(function () {\n  this.resource("pins", { path: "/" }, function () {\n    this.resource("pin", { path: "/:pin_id" });\n  });\n});\n')),Object(a.b)("p",null,"and when the user selects a pin, the overlay panel appears. The map making up the main screen is a ",Object(a.b)("inlineCode",{parentName:"p"},"FullscreenMapComponent"),', and the portion corresponding to "Street View" in the Google snapshot is a ',Object(a.b)("inlineCode",{parentName:"p"},"StreetViewComponent"),"."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"The problem")),Object(a.b)("p",null,'When the user clicks "Street View", we want the main map to pan and zoom to the selected pin. How can we accomplish this? The ',Object(a.b)("inlineCode",{parentName:"p"},"StreetViewComponent")," is in the ",Object(a.b)("inlineCode",{parentName:"p"},"PinController"),", and the map is a completely seprate component in a different controller."),Object(a.b)("p",null,"Using data-binding we could introduce a dummy property, have the street view component change that property, and have the fullscreen component respond to changes on that property; but this feels hackish, and the dummy variable wouldn't really represent anything meaningful in our application."),Object(a.b)("p",null,"What we really want is for our ",Object(a.b)("inlineCode",{parentName:"p"},"StreetViewComponent")," to send out an action called, say, ",Object(a.b)("inlineCode",{parentName:"p"},"focusSelectedPin"),", and then have our ",Object(a.b)("inlineCode",{parentName:"p"},"FullscreenMapComponent")," respond to that action and invoke the appropriate method. However, if we send out an action from our street view, whichever controller or route that handles the action won't have a reference to the ",Object(a.b)("inlineCode",{parentName:"p"},"FullscreenMapComponent"),", so it won't be able to invoke any of the component's methods."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"The solution")),Object(a.b)("p",null,"We can solve this problem by having our fullscreen component register a reference to itself upon initialization."),Object(a.b)("p",null,"First, add a method to the component that executes on init:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),'App.FullscreenMapComponent = Ember.Component.extend({\n  // ...\n\n  _registerWithTarget: Ember.observer("init", function () {\n    this.set("register-as", this); // register-as is a new property\n  }),\n});\n')),Object(a.b)("p",null,"Then, when rendering the component, supply a property to bind ",Object(a.b)("inlineCode",{parentName:"p"},"register-as")," to:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-handlebars"}),"\x3c!-- templates/pins.hbs --\x3e\n\n{{fullscreen-map data=mapData register-as=fullscreenMap }}\n")),Object(a.b)("p",null,"Now, our controller has a reference to the component, and can call methods directly on it. For example, if clicking our street view component sends out a ",Object(a.b)("inlineCode",{parentName:"p"},"focusSelectedPin")," action, we could handle it like this:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),'App.PinsRoute = Em.Route.extend({\n  // ...\n\n  actions: {\n    focusSelectedPin: function () {\n      this.controller.get("fullscreenMap").panToSelectedPin();\n    },\n  },\n});\n')),Object(a.b)("p",null,"Presto! Now our components can respond to actions."),Object(a.b)("p",null,Object(a.b)("em",{parentName:"p"},"Thanks to ",Object(a.b)("a",c({parentName:"em"},{href:"http://www.twitter.com/ebryn"}),"@ebryn")," for this solution.")))}u.isMDXComponent=!0},WlHn:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/getting-ember-components-to-respond-to-actions",function(){return n("Kpt1")}])}},[["WlHn",0,2,1,3,4,5,6]]]);