_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[34],{BphP:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/lowest-common-ancestor",function(){return n("Yiru")}])},Yiru:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"default",(function(){return h}));var a=n("rePB"),o=n("Ff2n"),i=(n("q1tI"),n("7ljp")),l=n("ZDfL");function p(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?p(Object(n),!0).forEach((function(t){Object(a.a)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):p(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var r={title:"Lowest Common Ancestor",date:"2015-12-08",__resourcePath:"blog/lowest-common-ancestor/index.mdx",__scans:{},layout:"index"},c={frontMatter:r},b=l.a;function h(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)(b,s(s(s({},c),n),{},{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"One of the biggest challenges when writing a JavaScript application is keeping multiple parts of the interface in sync. A user interaction in one part of the interface often affects data in another. If not managed well, this data can end up in multiple places, but with inconsistent values."),Object(i.b)("img",{src:"/_next/static/media/1-gmail.1f72a1afa59432ff350ef41fab4cc5cb.gif"}),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"Email 1 being unread is a piece of application state that affects multiple parts of the interface. After the email is read, the title should no longer be bold, and and Inbox unread count should decrease by one.")),Object(i.b)("p",null,"In the past few years, the JavaScript community has learned a lot about how to deal with this problem. The solution involves the principle of the ",Object(i.b)("strong",{parentName:"p"},"Lowest Common Ancestor"),". To explain this principle, let's look at some interface elements you might build while working on a real-world application."),Object(i.b)("p",null,"The examples use Ember, but the principles are high level and apply to any technology used for building long-lived JavaScript applications."),Object(i.b)("h2",null,"A collapsible panel (a single view of app state)"),Object(i.b)("p",null,"Let's say we're building an app with a collapsible panel:"),Object(i.b)("img",{src:"/_next/static/media/2-panel.212ca3ec79877beb94bfa0544ba4dd5d.gif"}),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"A collapsible panel, an element that opens and closes when the user clicks on it.")),Object(i.b)("p",null,"Here's the component's template:"),Object(i.b)("pre",null,Object(i.b)("code",s({parentName:"pre"},{className:"language-handlebars"}),"<a {{action 'toggleIsOpen'}}>\n  Panel Title\n</a>\n\n{{#if isOpen}}\n  <div>Anim pariatur cliche...</div>\n{{/if}}\n")),Object(i.b)("p",null,"If the panel ",Object(i.b)("inlineCode",{parentName:"p"},"isOpen"),", we'll show the body. Clicking the title triggers the ",Object(i.b)("inlineCode",{parentName:"p"},"toggleIsOpen")," action."),Object(i.b)("p",null,"Here's the component's JavaScript:"),Object(i.b)("pre",null,Object(i.b)("code",s({parentName:"pre"},{className:"language-js"}),'export default Ember.Component.extend({\n  isOpen: true,\n\n  actions: {\n    toggleIsOpen() {\n      this.toggleProperty("isOpen");\n    },\n  },\n});\n')),Object(i.b)("p",null,"The default value of ",Object(i.b)("inlineCode",{parentName:"p"},"isOpen")," is ",Object(i.b)("inlineCode",{parentName:"p"},"true"),", so the panel starts out open. Whenever a user clicks the title, ",Object(i.b)("inlineCode",{parentName:"p"},"isOpen")," toggles between ",Object(i.b)("inlineCode",{parentName:"p"},"true")," and ",Object(i.b)("inlineCode",{parentName:"p"},"false"),"."),Object(i.b)("hr",null),Object(i.b)("p",null,"Currently, our application looks like this:"),Object(i.b)("img",{src:"/_next/static/media/3-panel.d4d1fc73950a590636ed1354d87f673b.jpg"}),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"isOpen"),' is the only piece of state in our application that changes. Further, the collapsible panel is the only part of the interface that needs to know about it. Because of this, it makes sense for the panel itself to "own" this piece of application state. So, we\'ll leave ',Object(i.b)("inlineCode",{parentName:"p"},"isOpen")," right where it is - as a simple property on the component."),Object(i.b)("h2",null,"Adding a button (multiple views of app state)"),Object(i.b)("p",null,'We have a new feature request: adding a separate button which can also toggle the panel. The button should also say "Expand" or "Collapse", depending on the state of the panel.'),Object(i.b)("img",{src:"/_next/static/media/4-panel.a585e20579e55c4bd196e24028ffc483.gif"}),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"A collapsible panel and a button, which both depend on the same state.")),Object(i.b)("p",null,"We now have two elements in our application whose view depends on the same piece of state. What should we do?"),Object(i.b)("p",null,"One option is to add an ",Object(i.b)("inlineCode",{parentName:"p"},"isOpen")," property to our ",Object(i.b)("inlineCode",{parentName:"p"},"<button>")," component, and try to keep both properties in sync:"),Object(i.b)("img",{src:"/_next/static/media/5-panel.973228bad5e39ed5ef2ae6a189367c81.png"}),Object(i.b)("p",null,"But, duplicating state like this is not a good solution, because it can easily lead to an inconsistent interface."),Object(i.b)("p",null,"A better solution is to move the state up a level to ",Object(i.b)("inlineCode",{parentName:"p"},"<app>"),", and have ",Object(i.b)("inlineCode",{parentName:"p"},"<app>")," pass down ",Object(i.b)("inlineCode",{parentName:"p"},"isOpen")," to both ",Object(i.b)("inlineCode",{parentName:"p"},"<collapsible-panel>")," and ",Object(i.b)("inlineCode",{parentName:"p"},"<button>"),":"),Object(i.b)("img",{src:"/_next/static/media/6-panel.aa216a8bd74347fdf214b23ad874ce03.png"}),Object(i.b)("p",null,"Think of the ",Object(i.b)("inlineCode",{parentName:"p"},"isOpen")," properties on the two children as read-only pointers to the ",Object(i.b)("inlineCode",{parentName:"p"},"isOpen")," property on ",Object(i.b)("inlineCode",{parentName:"p"},"<app>"),". Now, both ",Object(i.b)("inlineCode",{parentName:"p"},"<collapsible-panel>")," and ",Object(i.b)("inlineCode",{parentName:"p"},"<button>")," are guaranteed to stay in sync, since they're rendered from the same state."),Object(i.b)("p",null,"Here's the template for ",Object(i.b)("inlineCode",{parentName:"p"},"<app>"),":"),Object(i.b)("pre",null,Object(i.b)("code",s({parentName:"pre"},{className:"language-handlebars"}),"{{collapsible-panel\n  isOpen=isOpen\n  onClick=(action 'toggleIsOpen')\n}}\n\n{{button\n  isOpen=isOpen\n  onClick=(action 'toggleIsOpen')\n}}\n")),Object(i.b)("p",null,"And here's the JS, which looks exactly the same as ",Object(i.b)("inlineCode",{parentName:"p"},"<collapsible-panel>")," did in the first example:"),Object(i.b)("pre",null,Object(i.b)("code",s({parentName:"pre"},{className:"language-js"}),'export default Ember.Component.extend({\n  isOpen: true,\n\n  actions: {\n    toggleIsOpen() {\n      this.toggleProperty("isOpen");\n    },\n  },\n});\n')),Object(i.b)("p",null,"When the user clicks either the ",Object(i.b)("inlineCode",{parentName:"p"},"<collapsible-panel>")," or the ",Object(i.b)("inlineCode",{parentName:"p"},"<button>"),", we'll send an action up to ",Object(i.b)("inlineCode",{parentName:"p"},"<app>"),", which will then change its ",Object(i.b)("inlineCode",{parentName:"p"},"isOpen")," property. The new value of ",Object(i.b)("inlineCode",{parentName:"p"},"isOpen")," propogates throughout the rest of the app, and the problem of inconsistent interface elements goes away."),Object(i.b)("p",null,"Crucially, we've made sure that only the owner of the state - ",Object(i.b)("inlineCode",{parentName:"p"},"<app>"),", in this case - is able to change that state. The children delegate their actions up to the owner."),Object(i.b)("hr",null),Object(i.b)("p",null,"By moving the state up to ",Object(i.b)("inlineCode",{parentName:"p"},"<app>")," and giving ",Object(i.b)("inlineCode",{parentName:"p"},"isOpen")," a single source of truth, we were able to ensure that ",Object(i.b)("inlineCode",{parentName:"p"},"<collapsible-panel>")," and ",Object(i.b)("inlineCode",{parentName:"p"},"<button>")," would never fall out of sync."),Object(i.b)("p",null,"In the example above, ",Object(i.b)("inlineCode",{parentName:"p"},"<app>")," was the ",Object(i.b)("em",{parentName:"p"},"only")," ancestor of both components in our component tree. Say we had a larger app:"),Object(i.b)("img",{src:"/_next/static/media/7-panel.1afe167dd7e986b77e7f716c8a1b00d0.png"}),Object(i.b)("p",null,"In this case, it would be sufficient to move ",Object(i.b)("inlineCode",{parentName:"p"},"isOpen")," to ",Object(i.b)("inlineCode",{parentName:"p"},"<main>")," to ensure ",Object(i.b)("inlineCode",{parentName:"p"},"isOpen")," had a single source of truth."),Object(i.b)("p",null,"Now, a definition. Given a set of components, the ",Object(i.b)("em",{parentName:"p"},"Lowest Common Ancestor")," of this set is the component that's deepest in the UI tree but still above each component in that set."),Object(i.b)("p",null,"This definition along with the discussion above leads us to the following general principle:"),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},Object(i.b)("em",{parentName:"p"},"When dealing with changing application state that lives in your UI hierarchy, store that state in the ",Object(i.b)("strong",{parentName:"em"},"Lowest Common Ancestor")," of all components that need it."))),Object(i.b)("p",null,"Storing shared state on the LCA, and then having that common ancestor pass its state to the relevant children, ensures that the state will have a single source of truth, and that every component that renders from that state will stay in sync."),Object(i.b)("p",null,"Note that it can sometimes be convenient to create a new common ancestor component, just for the sake of owning and managing the shared state."),Object(i.b)("h2",null,"Adding a logout button (pulling app state out of the UI)"),Object(i.b)("p",null,"In many situations, the principle of LCA is sufficient. State has a single source of truth, and is passed down to all children who need it. The problem you can run into, however, is when the LCA is very far away in your component hierarchy from the relevant children."),Object(i.b)("p",null,"In this case, you can end up with many components acting as middlemen. These components must know about and pass along various pieces of shared state to leaf components, making your UI difficult to refactor. There's even a ",Object(i.b)("a",s({parentName:"p"},{href:"https://sourcemaking.com/refactoring/smells/middle-man"}),"code smell of the same name")," in object-oriented design, suggesting that this is indeed a concern."),Object(i.b)("p",null,"An example of how this could happen is if many components in your app needed to know about the current user:"),Object(i.b)("img",{src:"/_next/static/media/8-panel.854661c10c93eacffbc55135c6623c72.png"}),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"In this app, many components need to know about the current user.")),Object(i.b)("p",null,"Assuming this many nodes need to know about the current user, the LCA would be ",Object(i.b)("inlineCode",{parentName:"p"},"<app>"),", and every component would need to pass along ",Object(i.b)("inlineCode",{parentName:"p"},"currentUser")," to every other component. This definitely smells like Middle Man."),Object(i.b)("p",null,"The solution to this problem is to ",Object(i.b)("em",{parentName:"p"},"pull the state out of the UI hierarchy"),". The idea here is that, while ",Object(i.b)("inlineCode",{parentName:"p"},"isOpen")," in our earlier example corresponded directly to a particular onscreen UI element (whether the panel was open), ",Object(i.b)("inlineCode",{parentName:"p"},"currentUser")," does not. So, it doesn't really make sense for ",Object(i.b)("inlineCode",{parentName:"p"},"<app>"),' (or any other UI element) to "own" ',Object(i.b)("inlineCode",{parentName:"p"},"currentUser"),"."),Object(i.b)("p",null,"In Ember, we can use a Service to solve this problem (in React, you might use a Flux store). A Service is a long-lived data container that exists independent of the UI tree. After we set it up, components can use ",Object(i.b)("em",{parentName:"p"},"dependency injection")," to ask for the data in the Service. Importantly, their parent components are none the wiser."),Object(i.b)("pre",null,Object(i.b)("code",s({parentName:"pre"},{className:"language-js"}),'// app/services/current-user.js\nexport default Ember.Service.extend({\n  name: "Bob",\n  email: "bob@acme.com",\n});\n\n// app/components/sidebar.js\nexport default Ember.Component.extend({\n  currentUser: Ember.inject.service("current-user"),\n});\n')),Object(i.b)("p",null,"Now, ",Object(i.b)("inlineCode",{parentName:"p"},"<sidebar>")," can access ",Object(i.b)("inlineCode",{parentName:"p"},"currentUser")," in its template:"),Object(i.b)("pre",null,Object(i.b)("code",s({parentName:"pre"},{className:"language-handlebars"}),"<h2>{{currentUser.name}}</h2>\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"<sidebar>")," has become more self-contained, making it easier to move around in the UI in later refactorings."),Object(i.b)("h2",null,"Conclusion"),Object(i.b)("p",null,"So, when should application state exist in the UI hierarchy, and when should it be pulled out? As in most areas of software design, there is no black and white answer. Instead, we must understand the tradeoffs involved, and make decisions on a case-by-case basis."),Object(i.b)("p",null,'State that\'s stored directly in the UI hierarchy is often easier to understand and requires less boilerplate; but, the more components that need a particular piece of state, the more brittle your UI hierarchy becomes. Eventually, it makes sense to move "popular state" into a UI-independent data container, an identity map which other components can read from.'),Object(i.b)("p",null,"The key insight is that ",Object(i.b)("em",{parentName:"p"},"all changing application state should have a single owner"),", and thus a single source of truth. Further, only the owner should be allowed to mutate that state. If the state lives in the UI hierarchy, the single owner should be the Lowest Common Ancestor of all components that need that state."),Object(i.b)("p",null,"To summarize,"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Start by storing state on local component instances"),Object(i.b)("li",{parentName:"ol"},"Once a piece of application state is needed by more than one component, move that state up to the LCA"),Object(i.b)("li",{parentName:"ol"},"Once there are many components acting as middlemen, or it feels wrong for any particular component to own some state, pull that state out of the UI hierarchy and into a data container (an Ember Service, a Flux store, etc.)")),Object(i.b)("p",null,"While our example above might seem simple enough, this pattern goes a long way in keeping your application's architecture consistent and easy to reason about."))}h.isMDXComponent=!0}},[["BphP",0,2,1,3,4,5,6]]]);