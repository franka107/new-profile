_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[29],{MAsa:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/how-ember-data-affects-data-down-actions-up",function(){return n("sw1H")}])},sw1H:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return p})),n.d(t,"default",(function(){return h}));var a=n("rePB"),o=n("Ff2n"),i=(n("q1tI"),n("7ljp")),s=n("ZDfL");function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){Object(a.a)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var p={title:"How Ember Data affects data down, actions up",date:"2014-12-24",__resourcePath:"blog/how-ember-data-affects-data-down-actions-up/index.md",__scans:{},layout:"index"},c={frontMatter:p},d=s.a;function h(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)(d,l(l(l({},c),n),{},{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"In anticipation of Ember 2.0 I've been experimenting with writing one of my applications as a tree of nested components. Something like"),Object(i.b)("pre",null,Object(i.b)("code",l({parentName:"pre"},{className:"language-handlebars"}),"<lesson-creator>\n  <main-intro> .. </main-intro>\n\n  <question-list questions=lesson.questions>\n    {{#each question in lesson.questions}}\n      <question-list-item item=question>\n    {{/each}}\n  </question-list>\n</lesson-creator>\n")),Object(i.b)("p",null,"Building my app like this has forced me to think about how exactly data down, actions up (DDAU) should work in Ember."),Object(i.b)("p",null,"In its most pure form, DDAU mandates capturing even ",Object(i.b)("inlineCode",{parentName:"p"},"change")," events on ",Object(i.b)("inlineCode",{parentName:"p"},"<input>")," fields, and using our components to handle the events in our data layer:"),Object(i.b)("pre",null,Object(i.b)("code",l({parentName:"pre"},{className:"language-js"}),'// pseudo code\n$("input").on("change", function (e) {\n  e.preventDefault();\n\n  this.send("updateValue", this.val());\n});\n')),Object(i.b)("p",null,"The action is handled upstream, the data is updated, and the new data propagates back down to the ",Object(i.b)("inlineCode",{parentName:"p"},"<input>")," field and its val is updated."),Object(i.b)("p",null,"Though I do see the elegance of structuring your entire application like this, it feels a bit like sacrificing pragmatism on the altar of DDAU. Indeed even React offers ",Object(i.b)("a",l({parentName:"p"},{href:"http://facebook.github.io/react/docs/two-way-binding-helpers.html"}),"a link helper"),", since the entire purpose of an ",Object(i.b)("inlineCode",{parentName:"p"},"<input>")," element is to mutate data."),Object(i.b)("p",null,"So, maybe DDAU is more of a guiding philosophy than a rigid principle. But, what exactly is the philosophy? That two-way bindings are only allowed on input fields? I actually think the scope may be much broader than that."),Object(i.b)("p",null,"In a React app, data is being passed around every which way. Each component has its own POJOs, and components render child components sending those POJOs in. One of the main points of DDAU is that parent components own their POJOs, and children shouldn't be able to mutate that data willy nilly from underneath their feet. This makes a lot of sense. The data is just free-floating data within the component's scope, and that component needs to have a guarantee that ",Object(i.b)("em",{parentName:"p"},"it")," decides when and how that data will change."),Object(i.b)("p",null,"With Ember + Ember Data, though, we're not just dealing with POJOs. Ember Data's store gives us an identity map, and together Ember and ED are responsible for data consistency. I think this has implications for the \"actions up\" part of DDAU. For instance, say I'm working with an ",Object(i.b)("inlineCode",{parentName:"p"},"<answer-list>")," that's deeply nested somewhere within my app. This component takes a question and an array of answers (think a teacher writing a multiple-choice question for a test). The ",Object(i.b)("inlineCode",{parentName:"p"},"<answer-list>")," contains a button that allows the teacher to add a new answer to the question:"),Object(i.b)("pre",null,Object(i.b)("code",l({parentName:"pre"},{className:"language-handlebars"}),"{{!-- components/answer-list/template.handlebars --}}\n{{#each answer in answers}}\n  ...\n{{/each}}\n\n<button {{action 'addAnswer' question}}>Add a new answer</button>\n")),Object(i.b)("p",null,"Say I handle the action directly in the ",Object(i.b)("inlineCode",{parentName:"p"},"<answer-list>")," component, like this:"),Object(i.b)("pre",null,Object(i.b)("code",l({parentName:"pre"},{className:"language-js"}),"//components/answer-list/component.js\n...\nactions: {\n  addAnswer: function(question) {\n    question.addAnswer(); // assume a method addAnswer exists on the question\n  }\n}\n")),Object(i.b)("p",null,"This clearly violates actions up, since whichever parent is rendering the ",Object(i.b)("inlineCode",{parentName:"p"},"<action-list>")," didn't send the event handler down. However, ",Object(i.b)("inlineCode",{parentName:"p"},"question")," here isn't simply some local POJO. While the property is in its own scope within the ",Object(i.b)("inlineCode",{parentName:"p"},"<action-list>")," component, it resolves to the same thing as its parent: a single, unique ",Object(i.b)("inlineCode",{parentName:"p"},"question")," model within Ember Data's store."),Object(i.b)("p",null,"In some sense, this component directly invoking ",Object(i.b)("inlineCode",{parentName:"p"},"question.addAnswer"),' is like sending a message straight to the "top" of our application. The question model creates a new answer model directly in the store, and all changes percolate down through our app\'s component hierarchy. It\'s almost like "actions up," except these components have a direct line of communication to the store.'),Object(i.b)("p",null,"The alternative is for the (say) ",Object(i.b)("inlineCode",{parentName:"p"},"<multiple-choice-question>")," parent to pass down a ",Object(i.b)("inlineCode",{parentName:"p"},"handleAddAnswer")," handler into the ",Object(i.b)("inlineCode",{parentName:"p"},"<answer-list>"),". But ",Object(i.b)("inlineCode",{parentName:"p"},"<multiple-choice-answer>")," isn't the originator of the question model either; it gets its data from above, and so on, all the way up to the route."),Object(i.b)("p",null,"The question is, with Ember Data's identity map, does it really make sense to require that these types of event handlers be defined in the tops of our component trees?"),Object(i.b)("p",null,"Consider something even more specific: an ",Object(i.b)("inlineCode",{parentName:"p"},"<add-answer-button>"),". This is a component that's part of our application's domain. Should it know how to add an answer to the ",Object(i.b)("inlineCode",{parentName:"p"},"store"),"? When other developers look at our app and see that component, are they going to be confused about where the new answer is coming from?"),Object(i.b)("p",null,'Ember allows us to build complex, dynamic UIs. I know personally as I develop Ember apps, the UI changes a lot. "Refactoring" is often rearranging UI elements, for purposes of either styling or functionality. But if I write an ',Object(i.b)("inlineCode",{parentName:"p"},"<add-answer-button>"),", I'm going to want it to add an answer when the user clicks on it, regardless of where I put it. However, if I require the handler be sent in, refactoring the UI will mean touching many other templates to ensure the action is passed down."),Object(i.b)("p",null,"This is even more true for something like a ",Object(i.b)("inlineCode",{parentName:"p"},"<logout-button>"),". I want this button to logout a user and redirect to the index route, regardless of where I put it. If it happens to be nested within a ",Object(i.b)("inlineCode",{parentName:"p"},"<question-list"),", is it really necessary to turn ",Object(i.b)("inlineCode",{parentName:"p"},"<question-list>")," into a middleman for the action handler?"),Object(i.b)("p",null,"Part of me is playing devil's advocate here, but part of me really thinks the store obviates the need for strict adherence to DDAU. We're using components to divy up our UIs. The store is responsible for data consistency. If we want to create an ",Object(i.b)("inlineCode",{parentName:"p"},"<add-answer-button>")," component because it is a logical coherant unit of UI + functionality, and we want that button to add an answer, then that component should know how to add an answer. It doesn't need to ask its parent. That's its job within the system: to render a button that adds an answer. And that will continue to be its job, regardless of where it lives."),Object(i.b)("p",null,"Now, there is one type of component where I think stricter adherence to DDAU makes sense: completely generic, reusable components. Datepickers and such, the kind of thing ",Object(i.b)("inlineCode",{parentName:"p"},"Ember.Component")," was originally created for."),Object(i.b)("p",null,"If I'm working on a ",Object(i.b)("inlineCode",{parentName:"p"},"<answer-list>")," component within my app, and I want to bring in a fancy 3rd-party ",Object(i.b)("inlineCode",{parentName:"p"},"<bootstrap-panel>")," to spruce up my UI, I shouldn't have to worry about that component mutating my data. A panel component doesn't know it's part of a Lesson Creator app, and I wouldn't want it touching my store."),Object(i.b)("p",null,"But, my current thinking tells me that components specific to our application's domain may have the right to directly mutate data."))}h.isMDXComponent=!0}},[["MAsa",0,2,1,3,4,5,6]]]);