_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[22],{"8YH7":function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/data-down-actions-up",function(){return n("weLn")}])},weLn:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return d})),n.d(t,"default",(function(){return h}));var a=n("rePB"),r=n("Ff2n"),o=(n("q1tI"),n("7ljp")),i=n("ZDfL");function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){Object(a.a)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var d={title:"Data down, actions up",date:"2014-11-26",__resourcePath:"blog/data-down-actions-up/index.md",__scans:{},layout:"index"},l={frontMatter:d},p=i.a;function h(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)(p,s(s(s({},l),n),{},{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,'Ember 2.0 is embracing some new patterns to ensure your apps stay clear and maintainable as they grow in complexity. One of these patterns is "data down, actions up." But what does that mean?'),Object(o.b)("p",null,"Here's a good way to think about it. Let's say we're making something like Trello, and our index route looks like this:"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),'//routes/index.js\nexport default Ember.Route.extend({\n  model: function () {\n    return this.store.find("card");\n  },\n});\n')),Object(o.b)("p",null,"We want to display the cards in our template:"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-handlebars"}),"\x3c!-- templates/index.hbs --\x3e\n\n<div class='board'>\n  {{#each card in controller}}\n    {{card-summary card=card}}\n  {{/each}}\n</div>\n")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Note: Soon, this will simply be ",Object(o.b)("inlineCode",{parentName:"p"},"each card in cards"),". No more proxies.")),Object(o.b)("p",null,"We've made a ",Object(o.b)("inlineCode",{parentName:"p"},"CardSummaryComponent")," to wrap up the display logic for each card we're showing. Let's say this summary shows the title of the card, and has an \"X\" button in the top-right which lets our users delete the card. We can imagine writing something like this:"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-handlebars"}),"\x3c!-- templates/components/card-summary.hbs --\x3e\n\n<div class='card'>\n  <h2>{{card.title}}</h2>\n  <span {{action 'removeCard'}} class='fa fa-remove'> X </span>\n</div>\n")),Object(o.b)("p",null,"and the component code"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),'//components/card-summary.js\nexport default Ember.Component.extend({\n  actions: {\n    removeCard: function () {\n      return this.get("card").destroyRecord();\n    },\n  },\n});\n')),Object(o.b)("p",null,"Now, the problem here is that the ",Object(o.b)("inlineCode",{parentName:"p"},"CardSummaryComponent")," is deleting the data, but it's really the ",Object(o.b)("inlineCode",{parentName:"p"},"IndexController")," that ",Object(o.b)("em",{parentName:"p"},"owns")," the data. Its the one that passed the ",Object(o.b)("inlineCode",{parentName:"p"},"card")," into the ",Object(o.b)("inlineCode",{parentName:"p"},"CardSummaryComponent"),", and now that component has gone and deleted its data right out from under its feet. This is sort of thing that becomes really difficult to trace in larger, more complex applications."),Object(o.b)("p",null,"Note that in Ember 2.0, we wouldn't have an ",Object(o.b)("inlineCode",{parentName:"p"},"IndexController")," but rather a routable component. We don't know exactly how the API will shake out, but somehow we'd end up with a component that has an ",Object(o.b)("inlineCode",{parentName:"p"},"attrs.cards")," property from the server, which would be the array of cards. We'd probably then make a separate ",Object(o.b)("inlineCode",{parentName:"p"},"CardSummaryListComponent")," and do something like ",Object(o.b)("inlineCode",{parentName:"p"},"{{card-summary-list cards=cards}}"),"."),Object(o.b)("p",null,'In any case, back to the example. This clearly violates "data down", because there was a data change in a child component (',Object(o.b)("inlineCode",{parentName:"p"},"CardSummary"),") which affected parent components (in this case the ",Object(o.b)("inlineCode",{parentName:"p"},"each")," block, in the alternative case the ",Object(o.b)("inlineCode",{parentName:"p"},"CardSummaryList")," component)."),Object(o.b)("p",null,"To revise this, first, pretend that you live in a world without two-way bindings. That is, when we render ",Object(o.b)("inlineCode",{parentName:"p"},"{{card-summary card=card}}"),", what's actually happening is the ",Object(o.b)("inlineCode",{parentName:"p"},"card"),' from the parent scope is being "copied", and passed into component, which now has the data in its own isolated scope. Any change to ',Object(o.b)("inlineCode",{parentName:"p"},"card")," in the parent scope will re-push that data into the ",Object(o.b)("inlineCode",{parentName:"p"},"card-summary"),' component, which is the "data down" part. But, if the ',Object(o.b)("inlineCode",{parentName:"p"},"card-summary")," component mutates its own ",Object(o.b)("inlineCode",{parentName:"p"},"card")," data, none of its parent components will be the wiser. That's one-way bindings."),Object(o.b)("p",null,'But of course, we want those interactions in our child components to actually affect our real data. So, we use actions to send those messages back up our hierarchy. This is "actions up", and the idea is that our ',Object(o.b)("inlineCode",{parentName:"p"},"card-summary"),' component is simply "notifying" its parent components that a certain action has taken place - "deleteCard", for example. It\'s up to the parent components to decide how they want to handle the actions their children are emitting.'),Object(o.b)("p",null,"In React, those parent components do this by explicitly passing their action handlers into their children. Something like this:"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"//components/card-summary-list.js\n\n// Here's the JSX template for a <CardSummaryList>\ncards.map(function (card) {\n  return <CardSummary card={card} onCardDelete={this.handleCardDelete} />;\n});\n")),Object(o.b)("p",null,"Here, ",Object(o.b)("inlineCode",{parentName:"p"},"CardSummaryList")," is passing a handler down to its child. The ",Object(o.b)("inlineCode",{parentName:"p"},"CardSummary")," component can then simply invoke this handler in response to whatever event it chooses. The child determines the action, but the parent determines how the action is handled."),Object(o.b)("p",null,"In Ember, we're used to doing something more along the lines of"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-handlebars"}),"\x3c!-- templates/index.hbs --\x3e\n\n<div class='board'>\n  {{#each card in controller}}\n    {{card-summary card=card action='deleteCard'}}\n  {{/each}}\n</div>\n")),Object(o.b)("p",null,"and then writing the ",Object(o.b)("inlineCode",{parentName:"p"},"deleteCard")," handler within the parent. This is changing, for a few reasons (read the ",Object(o.b)("strong",{parentName:"p"},"Improving Actions")," section of ",Object(o.b)("a",s({parentName:"p"},{href:"https://github.com/emberjs/rfcs/pull/15"}),"the 2.0 RFC")," for more info). In 2.0 we'll be doing things similar to how React does it, by passing actions directly in:"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-handlebars"}),"\x3c!-- templates/index.hbs --\x3e\n\n<div class='board'>\n  {{#each card in controller}}\n    <card-summary card=card deleteCard={{action \"valueChanged\"}}>\n  {{/each}}\n</div>\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"CardSummary")," component will have access to that action via ",Object(o.b)("inlineCode",{parentName:"p"},"attrs['deleteCard']"),", and will be able to invoke it just like in React. This way, the child component is effectively delegating the event handler to the parent, without knowing anything about what that handler does. As an added bonus, the child can continue to pass the parent's handler further down to its own children - without the need for any ",Object(o.b)("inlineCode",{parentName:"p"},"sendAction")," boilerplate in the actual JS code."),Object(o.b)("hr",null),Object(o.b)("p",null,"This is a simple example of how \"data down, actions up\" should be influencing the architecture of your Ember apps. If you haven't already, I highly recommend spending several hours with React. It's a great way to learn about component-based architecture and immutability, two concepts that will be making a strong showing in Ember 2.0."))}h.isMDXComponent=!0}},[["8YH7",0,2,1,3,4,5,6]]]);