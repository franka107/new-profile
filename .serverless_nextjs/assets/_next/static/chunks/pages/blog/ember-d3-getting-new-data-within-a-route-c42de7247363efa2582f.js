_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[23],{"+5lU":function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/ember-d3-getting-new-data-within-a-route",function(){return n("ykV7")}])},ykV7:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"default",(function(){return h}));var a=n("rePB"),o=n("Ff2n"),r=(n("q1tI"),n("7ljp")),i=n("ZDfL");function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){Object(a.a)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var c={title:"Ember and D3: Getting new data within a route",date:"2013-07-28",__resourcePath:"blog/ember-d3-getting-new-data-within-a-route/index.md",__scans:{},layout:"index"},p={frontMatter:c},d=i.a;function h(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)(d,s(s(s({},p),n),{},{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"When doing datavis, you'll often want to display new data without changing the route of your appplication. For example, you may want to supplement a time series chart with a baseline render. These types of UI interactions are not meaningful enough to change the URL",Object(r.b)("sup",s({parentName:"p"},{id:"fnref-1"}),Object(r.b)("a",s({parentName:"sup"},{href:"#fn-1",className:"footnote-ref"}),"1")),", but they still may require an additional call to the server."),Object(r.b)("p",null,"Ember places a lot of emphasis on routing, so examples of fetching data from the server when switching routes are prevalent. But here, I want to look at fetching data without changing the route. Let's say part of our ",Object(r.b)("inlineCode",{parentName:"p"},"IndexRoute")," has a datepicker, and each time a user selects a month, we want to add some data to an existing chart."),Object(r.b)("p",null,"The first thing to remember is that in Ember, controllers can be thought of as data containers. Models act as proxies to your actual data on the server, but when it comes to actually displaying and manipulating data in your Ember app, controllers take center stage. So, to get some new data, the first step is to make a new controller. We'll use an ",Object(r.b)("inlineCode",{parentName:"p"},"ArrayController")," to hold all the months the user has selected:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"App.MonthsController = Ember.ArrayController.extend({});\n")),Object(r.b)("p",null,"This will be the container for our models."),Object(r.b)("p",null,"Now, we want to add some models to our controller. Again, because many Ember apps will only need new data upon entering a new route, you'll come across numerous guides on how to accomplish this that will point you to a controller's ",Object(r.b)("inlineCode",{parentName:"p"},"init")," function, or to the ",Object(r.b)("inlineCode",{parentName:"p"},"model")," or ",Object(r.b)("inlineCode",{parentName:"p"},"setupController")," hooks within a route. But that's not what we're interested in here. These components are part of Ember's sophisticated routing system, and while they work nicely when changing routes, we'll have to find another way."),Object(r.b)("p",null,"First, let's model our data:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),'App.Month = DS.Model.extend({\n  min: DS.attr("number"),\n  max: DS.attr("number"),\n  // (other data)\n});\n')),Object(r.b)("p",null,"How can we get new ",Object(r.b)("inlineCode",{parentName:"p"},"Month")," models into our controller? Let's start with the UI. Usually when dealing with datepickers, you'll need to write some Javascript. This means we'll probably need more than just a template to handle our user interactions. Let's create a view for our datepicker"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"App.DatepickerView = Ember.View.extend({\n  init: function () {\n    this.$().datepicker();\n  },\n});\n")),Object(r.b)("p",null,"and add it to our ",Object(r.b)("inlineCode",{parentName:"p"},"IndexRoute")),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-html"}),'// index.html\n\n<body>\n  <script type="text/x-handlebars" data-template-name="index">\n    <h1>Welcome to may app!</h1>\n    ...\n    <aside>\n       {{view App.DatepickerView}}\n    </aside>\n  <\/script>\n  ...\n</body>\n')),Object(r.b)("p",null,"Now, when a user clicks a month on our datepicker, we want to fetch some new data. Ultimately, we'll use the data to rerender our D3 chart - but in this post, I just want to focus on getting the data. If we were transitioning to a new route, we'd use the standard ",Object(r.b)("inlineCode",{parentName:"p"},"{{linkTo}}")," helper, and specify our data in the ",Object(r.b)("inlineCode",{parentName:"p"},"model")," hook of our route. Here, we'll have to write some custom methods."),Object(r.b)("p",null,"First, we'll want to handle the click event in our view. The details will vary depending on what datepicker you're using (or if you're writing your own), but you'll probably be able to access the selected date from the datepicker's api. But what are we going to do with the selected date? The view shouldn't be responsible for calling the server directly to get the new data - we already have a controller that should be managing that. So that's what we'll do - trigger an event that tells the controller to get some new data. First, tell the view to trigger the event:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),'App.DatepickerView = Ember.View.extend({\n  click: function (e) {\n    var id = this.$().datepicker().getDate();\n    this.get("controller.controllers.months").send("addMonth", id);\n  },\n});\n')),Object(r.b)("p",null,"In this example, the ",Object(r.b)("inlineCode",{parentName:"p"},"DatepickerView")," is in the ",Object(r.b)("inlineCode",{parentName:"p"},"IndexRoute"),", so its context is the ",Object(r.b)("inlineCode",{parentName:"p"},"IndexController"),". Since we need to send the ",Object(r.b)("inlineCode",{parentName:"p"},"addMonth")," event to the ",Object(r.b)("inlineCode",{parentName:"p"},"MonthsController"),", we need to teach our ",Object(r.b)("inlineCode",{parentName:"p"},"IndexController")," how to find the ",Object(r.b)("inlineCode",{parentName:"p"},"MonthsController"),". We do this using the ",Object(r.b)("inlineCode",{parentName:"p"},"needs")," property:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),'App.IndexController = Ember.Controller.extend({\n  needs: ["months"],\n});\n')),Object(r.b)("p",null,"Now, every time a user clicks a month, the view sends an ",Object(r.b)("inlineCode",{parentName:"p"},"addMonth")," event to the ",Object(r.b)("inlineCode",{parentName:"p"},"MonthsController"),". Let's write a method to handle this event. The goal is to fetch the new model from the server, and once it fetches, add it to the ",Object(r.b)("inlineCode",{parentName:"p"},"MonthsController"),". Any view that reads data from the ",Object(r.b)("inlineCode",{parentName:"p"},"MonthsController")," (for example, our hypothetical D3 chart) will then automatically update once the data comes in."),Object(r.b)("p",null,"Here's the method:"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-js"}),"App.MonthsController = Ember.ArrayController.extend({\n  actions: {\n    addMonth: function (id) {\n      var _this = this;\n      App.Month.find(id).then(function (month) {\n        _this.pushObject(month);\n      });\n    },\n  },\n});\n")),Object(r.b)("p",null,"Pretty simple, right? We add the month to the controller once its returned. And that's how you can get data to your controllers without changing routes."),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"This is Part 2 in a series of posts on building a basic interactive dashboard using ",Object(r.b)("a",s({parentName:"em"},{href:"http://www.d3js.org"}),"D3.js")," and ",Object(r.b)("a",s({parentName:"em"},{href:"http://www.emberjs.com"}),"Ember.js"),".")),Object(r.b)("div",s({},{className:"footnotes"}),Object(r.b)("hr",{parentName:"div"}),Object(r.b)("ol",{parentName:"div"},Object(r.b)("li",s({parentName:"ol"},{id:"fn-1"}),"In other words, it may not be appropriate to structure the output resulting from the user's interaction as a new resource.",Object(r.b)("a",s({parentName:"li"},{href:"#fnref-1",className:"footnote-backref"}),"\u21a9")))))}h.isMDXComponent=!0}},[["+5lU",0,2,1,3,4,5,6]]]);